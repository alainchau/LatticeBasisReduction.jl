module LatticeBasisReduction

export gram_schmidt, LLL

include("misc.jl")

# Julia implementation of the Lenstra-Lenstra-Lovasz lattice basis reduction algorithm.

"""
Return orthogonal basis and the Gram Schmidt coefficient matrix.

# Example

```julia
julia> X = (Float64)[
        [ 3  -1   5]
        [-5   2  -1]
        [-3   9   2]
    ]

julia> X_star, M = gram_schmidt(X)
(
[3.0 -1.0 5.0; -3.11429 1.37143 2.14286; 2.68728 6.5689 -0.298587],

[1.0 0.0 0.0; -0.628571 1.0 0.0; -0.228571 1.60601 1.0])
```
"""
function gram_schmidt(X)
    # Assume the vectors are given as row vectors of X
    # redo later since vectors in Julia are stored in column-major order.

    # Copy so we don't modify the original array.
    A = transpose(copy(X))

    # Array with same shape as A but filled with zeros
    A_star = zeros(A)

    # Coefficient matrix
    M = zeros(A)

    n_cols = size(A)[2]
    for i in 1:n_cols
        A_star[:, i] = A[:, i]
        for j in 1:i-1
            μ = dot(A[:, i], A_star[:, j]) / dot(A_star[:, j], A_star[:, j])
            M[j, i] = μ
            A_star[:, i] -= (μ * A_star[:, j])
        end
        M[i,i] = 1
    end
    return transpose(A_star), transpose(M)
end

"""
    LLL(x::Array{Float64,2}, α::Float64; verbose=false::Bool)

Return an α-reduced basis of the lattice generated by `x`, where 1/4 < α <= 1.

# Example

```
> x = [[-2 7 7 -5]
       [3 -2 6 -1]
       [2 -8 -9 -7]
       [8 -9 6 -4]]

```

"""
function LLL(x::Array{Float64, 2}, α::Float64; verbose=false::Bool)

    @assert 1/4 < α <= 1 ["Invalid value of α."]

    y = copy(x)
    n = size(y)[2]

    ystar, μ = gram_schmidt(y)

    # elementwise multiplication, followed by summing along rows
    gammax = sum(ystar .* ystar, 2)

    ##### Internal Methods ##########################################
    function reduce(k, ℓ)
        if abs(μ[k, ℓ]) > 1/2
            if verbose
                println("iteration $n_iter \t reduce \t k=$k \t ℓ=$ℓ \t [μ[k,l]] = $(round_ties_down(μ[k,ℓ]))")
                n_iter += 1
            end

            y[k, :] -= round_ties_down(μ[k, ℓ]) * y[ℓ, :]
            for j in 1:ℓ-1
                # rounding to nearest integer is default behavior
                μ[k, j] -= round_ties_down(μ[k, ℓ]) * μ[ℓ, j]
            end
            μ[k, ℓ] -= round_ties_down(μ[k, ℓ])
        end
    end

    function exchange(k)
        if verbose
            println("iteration $n_iter \t exchange \t k=$k")
            n_iter += 1
        end

        y[k-1, :], y[k, :] = y[k, :], y[k-1, :]
        nu = μ[k, k-1]
        δ = gammax[k] + nu^2 * gammax[k-1]
        μ[k, k-1] = nu * gammax[k-1] / δ
        gammax[k] = gammax[k] * gammax[k-1] / δ
        gammax[k-1] = δ

        for j in 1:k-2
            μ[k-1, j], μ[k, j]= μ[k, j], μ[k-1, j]
        end

        for i in k+1:n
            ξ = μ[i, k]
            μ[i, k] = μ[i, k-1] - nu * μ[i, k]
            μ[i, k-1] = μ[k, k-1] * μ[i, k] + ξ
        end
    end

    ##### Main Loop  ################################################
    n_iter = 1
    k = 2
    while k <= n
        reduce(k, k-1)
        if gammax[k] >= (α - μ[k, k-1]^2) * gammax[k-1]
            for ℓ = k-2 : -1 : 1
                reduce(k, ℓ)
            end
            k += 1
        else
            exchange(k)
            if k > 2
                k -= 1
            end
        end
    end
    return y
end

function LLL(x::Array{Float64, 2}, α::Int; verbose=false::Bool)
    LLL(x, Float64(α), verbose=verbose)
end

end
